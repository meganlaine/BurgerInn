#BlueJ class context
comment0.target=GuestTree
comment0.text=\n\ Class\ GuestTree\ creates\ a\ binary\ tree\ of\ Guest\ objects.\n\ \n\ @author\ Megan\ Laine\n\ @version\ 7\ Mar\ 2019\ CSC\ 143\n
comment1.params=
comment1.target=GuestTree()
comment1.text=\n\ GuestTree\ Constructor\ (default\ 1/2)\ constructs\ an\ empty\ search\ tree.\n
comment10.params=node
comment10.target=java.lang.String\ toStringPreorder(GuestTreeNode)
comment10.text=\n\ Returns\ a\ String\ of\ Guest\ info\ from\ the\ GuestTreeNode\ using\ pre-order\ traversal.\n\ \n\ @param\ node\ (GuestTreeNode)\ the\ GuestTreeNode\ to\ process\n
comment11.params=g
comment11.target=GuestTreeNode\ find(Guest)
comment11.text=\n\ Finds\ given\ Guest\ within\ a\ binary\ search\ tree;\ returns\ null\ if\ Guest\ is\ not\ found;\ \n\ otherwise\ returns\ the\ GuestTreeNode\ (Client\ will\ have\ to\ access\ Guest\ \n\ within\ the\ node\ returned\ to\ access\ or\ change\ data).\n\ \n\ @param\ g\ (Guest)\ the\ guest\ of\ interest.\n\ @return\ (GuestTreeNode)\ if\ found,\ or\ null\ if\ guest\ is\ not\ found.\n
comment12.params=g\ node
comment12.target=GuestTreeNode\ find(Guest,\ GuestTreeNode)
comment12.text=\n\ Finds\ given\ Guest\ within\ a\ GuestTreeNode;\ returns\ null\ if\ Guest\ is\ not\ found;\ \n\ otherwise\ returns\ the\ GuestTreeNode\ (Client\ will\ have\ to\ access\ Guest\ \n\ within\ the\ node\ returned\ to\ access\ or\ change\ data).\ \n\ \n\ @param\ g\ (Guest)\ the\ guest\ to\ look\ for.\n\ @param\ node\ (GuestTreeNode)\ the\ node\ to\ evaluate.\n\ @return\ result\ (GuestTreeNode)\ containing\ the\ matched\ item;\ or\ null\ if\ not\ found.\n
comment13.params=g
comment13.target=void\ remove(Guest)
comment13.text=\n\ Removes\ a\ GuestTreeNode\ based\ on\ the\ Guest\ parameter;\ if\ the\ guest\ is\ not\ found\ in\ \n\ the\ tree,\ nothing\ is\ done.\n\ \n\ @param\ g\ (Guest)\ the\ guest\ to\ find;\ remove\ the\ relevant\ node.\n
comment14.params=g\ node
comment14.target=GuestTreeNode\ remove(Guest,\ GuestTreeNode)
comment14.text=\n\ Private\ method\ to\ remove\ GuestTreeNodes\ from\ a\ GuestTree\ based\ on\ parameter\ GUEST;\ if\n\ the\ Guest\ is\ not\ found\ in\ the\ tree,\ returns\ a\ pointer\ to\ null;\n\ \n\ @param\ g\ (Guest)\ the\ guest\ to\ remove.\n\ @param\ node\ (GuestTreeNode)\ the\ node\ to\ check.\n\ @return\ the\ new\ node.\n
comment15.params=node
comment15.target=GuestTreeNode\ findMin(GuestTreeNode)
comment15.text=\n\ Private\ method\ to\ find\ the\ 'smallest'\ Guest\ in\ a\ subtree.\ 'Small'\ is\ equivalent\ to\n\ being\ lexicographically\ earlier\ in\ the\ alphabet.\ (For\ ex\:\ a\ comes\ before\ z;\ \n\ a's\ 'smaller').\n\ \n\ @param\ node\ (GuestTreeNode)\ the\ node\ to\ evaluate\n\ @return\ GuestTreeNode\ containing\ the\ 'smallest'\ Guest.\n
comment2.params=g
comment2.target=GuestTree(Guest)
comment2.text=\n\ GuestTree\ Constructor\ (2/2)\ constructs\ a\ search\ tree\ with\ the\ given\ Guest\ as\ overall\ \n\ root;\ there\ will\ be\ no\ child\ nodes\ to\ this\ new\ tree\ with\ 1\ node.\n\ \n\ @param\ g\ (Guest)\ the\ guest\ to\ set\ at\ the\ overall\ Root\ of\ the\ new\ Guest\ Tree.\n
comment3.params=g
comment3.target=void\ add(Guest)
comment3.text=\n\ (Public\ method)\ Adds\ a\ Guest\ to\ this\ GuestTree;\ preserves\ the\ binary\ search\ tree\ \n\ functionality\ of\ GuestTree.\n\n\ @param\ g\ (Guest)\ the\ guest\ to\ add\ to\ the\ tree.\n
comment4.params=node\ other
comment4.target=GuestTreeNode\ add(GuestTreeNode,\ Guest)
comment4.text=\n\ (Private\ method)\ Returns\ a\ GuestTreeNode\ with\ the\ given\ Guest\ object;\ preserves\ \n\ binary\ search\ tree\ functionality\ -\ relative\ to\ the\ root\ that\ the\ node\ will\ be\ added\ \n\ to;\ a\ recursive\ method.\n\n\ @param\ node\ (GuestTreeNode)\ a\ tree\ node\ to\ 'add'\ a\ Guest\ to\n\ @param\ other\ (Guest)\ the\ guest\ object\ to\ 'add'\ to\ the\ root\n\ @return\ root\ (GuestTreeNode)\ with\ modifications\n
comment5.params=g
comment5.target=boolean\ contains(Guest)
comment5.text=\n\ (Public\ method)\ Returns\ true\ if\ GuestTree\ contains\ value,\ returns\ false\ otherwise.\n\n\ @param\ g\ (Guest)\ A\ Guest\ to\ look\ for\n\ @return\ (boolean)\ true\ if\ the\ guest\ is\ found\ in\ the\ tree;\ false\ otherwise\n
comment6.params=other\ node
comment6.target=boolean\ contains(Guest,\ GuestTreeNode)
comment6.text=\n\ (Private\ method)\ Returns\ true\ if\ GuestTree\ contains\ value,\ returns\ false\ otherwise.\n\n\ @param\ node\ (GuestTreeNode)\ A\ guest\ tree\ node\ to\ assess\n\ @param\ other\ (Guest)\ A\ Guest\ to\ look\ for\n\ @return\ (boolean)\ true\ if\ the\ guest\ is\ found\ in\ the\ tree;\ false\ otherwise\n
comment7.params=
comment7.target=void\ print()
comment7.text=\n\ Prints\ Guest\ information\ from\ the\ GuestTree\ using\ in-order\ traversal;\ \n\ outputs\ to\ console\:\ one\ line\ per\ Guest.\n
comment8.params=node
comment8.target=void\ printInorder(GuestTreeNode)
comment8.text=\n\ Prints\ Guest\ information\ from\ the\ GuestTree\ using\ in-order\ traversal;\ \n\ outputs\ to\ console\:\ one\ line\ per\ Guest.\n\ \n\ @param\ node\ (GuestTreeNode)\ the\ GuestTreeNode\ to\ process\n
comment9.params=
comment9.target=java.lang.String\ toString()
comment9.text=\n\ Returns\ a\ String\ of\ Guest\ information\ from\ the\ GuestTree\ using\ pre-order\ traversal.\n
numComments=16
